**В общем случае переборный алгоритм состоит в генерации всех возможных вариантов и сравнении их между собой в поиске наилучшего.

Схема перебора всегда будет одинакова:

- надо установить ПОРЯДОК на элементах, подлежащих перечислению (в частности, определить, какой из них будет первым, а какой последним);

- научиться переходить от произвольного элемента к непосредственно следующему за ним (данное требование очень важно, т.к. возвращаться к пропущенным в процессе перебора элементам будет сложнее, чем задать алгоритм сплошного перебора)
##### Определения

**Перестановка** – это комбинация элементов из N разных элементов, взятых в определенном порядке. Необходимо отметить, что в перестановках порядок следования элементов важен и в перестановке должны быть задействованы все N элементов.

**Сочетания** - наборы элементов, которые отличаются хотя бы одним элементом, и каждый из которых (каждый набор) содержит всегда M элементов, взятых из разных N элементов. Важно, что в сочетаниях порядок следования элементов не учитывается.

**Размещения** - количество вариантов, которыми можно записать в ряд подпоследовательность из K элементов некоторой перестановки из N элементов. При этом последовательности из одинаковых элементов, но с различным их порядком следования считаются различными.

##### Алгоритм генерации сочетаний

Раз порядок элементов в соединении не существенен, то получаемые выборки элементов будем упорядочивать в порядке возрастания. В качестве начальной конфигурации возьмем S=(1,2, .., M), т.е. B[j] = j, для j [1..M].

Сочетания будем получать в возрастающем лексикографическом порядке, т.е. последним сочетанием будет S=(N-M+1, N-M+2, .., N). Для каждого элемента последнего сочетания будет выполняться условие: B[i] = N-M+i.

Для генерации очередного сочетания необходимо найти элемент B[i] с максимальным индексом i, таким чтобы выполнялось условие: B[i] < N-M+i. Для этого просмотр элементов массива следует делать справа налево. Затем найденное значение B[i] увеличим на 1, а для всех K > i, положим значение B[K] = B [K-1] + 1. Если же такого B [i] не существует, то генерация сочетаний длины M завершена.