Связный граф называется **эйлеровым**, если существует замкнутая цепь, проходящая через каждое его ребро. Такая цепь называется **эйлеровой цепью**. 

![](https://lh4.googleusercontent.com/2diTZm03ZIsxwBzNaIh1surO8PfBFAwE3J43u0foWhcZh8PHLgMAB3cr-qkSXOEZTLImuBHDDVDXqEko8xzxyqOgZKwQXyLMSMrRKWUuDDr-KBrd2LH9cEyFjVd7E79LckwHoPT3XnFFs3dGWxzTdKM)

  

Отметим, что в этом определении требуется, чтобы каждое ребро проходилось только один раз. Если снять ограничение на замкнутость цепи, то граф называется **полуэйлеровым**, при этом каждый эйлеров граф будет полуэйлеровым.

Принято всякую замкнутую линию, если ее можно начертить, не отрывая карандаша от бумаги, проходя при этом каждый участок в точности один раз, называть **уникурсальной**. Рисунок графа, обладающего эйлеровым путем или эйлеровым циклом(цепью), является уникурсальной линией.

- Граф является эйлеровым тогда и только тогда, когда он связный и не содержит вершин с нечётной степенью.
- Граф является эйлеровым тогда и только тогда, когда он может быть разбит на непересекающиеся по ребрам простые циклы.
- Граф является полуэйлеровым тогда и только тогда, когда он содержит ровно 0 или 2 вершины с нечетной степенью.
- Орграф является эйлеровым тогда и только тогда, когда он сильно связный и для каждой вершины входящая степень равна исходящей.
- Орграф является полуэйлеровым тогда и только тогда, когда он содержит не более одной вершины с indeg=outdeg+1 и не более одной вершины с outdeg=indeg+1, а все остальные вершины имеют равные входящие и исходящие степени. (indeg - степень входящих в него ребер, outdeg - степень исходящих из него ребер)

##### Поиск эйлерова цикла

Задача поиска эйлерова пути сводится к задаче поиска эйлерова цикла. Для этого нужно добавить ребро между 2 вершинами с нечётной степенью.

Алгоритм основан на том, что эйлеров цикл – это объединение всех простых циклов в графе. Предполагаем, что граф является эйлеровым.

**Псевдокод**

find_all_cycles (v)

1. пока есть цикл, проходящий через v находим его добавляем все вершины найденного цикла в массив cycles (сохраняя порядок обхода), удаляем цикл из графа //удаляем ребра, содержащиеся в этом цикле
2. идем по элементам массива cycles каждый элемент cycles[i] добавляем к ответу из каждого элемента рекурсивно вызываем себя: find_all_cycles (cycles[i])

Достаточно вызвать процедуру из любой вершины графа.

**Временная сложность**: O(|E|).
