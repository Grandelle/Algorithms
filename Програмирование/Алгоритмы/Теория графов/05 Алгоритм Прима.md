
- Множество А представляет собой одно дерево
- Безопасное ребро, добавляемое к А выбирается как ребро наименьшего веса, соединяющего уже построенное дерево с некоторой новой вершиной
- Построение остовного дерева начинается с одной вершины
- На каждом шаге добавляется ребро наименьшего веса, у которого одна вершина уже принадлежит построенному дереву, в вторая находится в множестве еще не присоединенных вершин

#### Программная реализация алгоритма Прима

При реализации надо уметь на каждом шаге быстро выбирать безопасное ребро. Для этого удобно воспользоваться очередью с приоритетами (кучей).

Алгоритм получает на вход граф G и его корень r – вершина, на которой будет наращиваться минимальный остов.

Все вершины G, еще не попавшие в дерево, хранятся в очереди с приоритетом Ω. Приоритет вершины v определяется значением key[v], которое равно минимальному весу ребер, соединяющих v с вершинами минимального остова. Поле p[v] для вершин дерева указывает на родителя, а для вершин из очереди, указывает на узел дерева, в которою ведет ребро с весом key[v] (одно из таких ребер, если их несколько).

##### Сложность:
- O(ElogV)

<iframe width="838" height="471" src="https://www.youtube.com/embed/3l6_sI5hjIM" title="Алгоритм Прима: поиск остовного дерева." frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>