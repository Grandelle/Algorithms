
**Поиск кратчайшего пути в графе**
**Формулировка задачи**:
	Дан ориентированный или неориентированный граф G со взвешенными рёбрами. Длиной пути назовём сумму весов рёбер, входящих в этот путь. Требуется найти кратчайшие пути от выделенной вершины s до всех вершин графа.

В графе не должно быть отрицательных циклов, достижимых из s.

##### Алгоритм Дейкстры.

Находит кратчайшее расстояние от одной из вершин графа до всех остальных. Алгоритм работает только для графов без рёбер отрицательного веса.

Шаги  алгоритма

Каждой вершине сопоставим метку – минимальное известное расстояние от этой вершины до вершины  a. Метка вершины a инициализируется 0, метки остальных вершин – бесконечностью. Все вершины кроме вершины a помечаются как непосещённые.

Если все вершины посещены, алгоритм завершается. В противном случае, из ещё не посещённых вершин выбирается вершина u, имеющая минимальную метку. Мы рассматриваем всевозможные маршруты, в которых u является предпоследним пунктом. Вершины, в которые ведут ребра из u, назовем соседями этой вершины. Для каждого соседа вершины u, кроме отмеченных как посещённые, рассмотрим новую длину пути, равную сумме значений текущей метки u и длины ребра, соединяющего u с этим соседом. Если полученное значение длины меньше значения метки соседа, заменим значение метки полученным значением длины. Рассмотрев всех соседей, пометим вершину u как посещённую и повторим шаг алгоритма.

Обозначения

- V — множество вершин графа
- E — множество ребер графа
- w[ij] — вес (длина) ребра ij
- a — вершина, расстояния от которой ищутся
- Q — множество непосещенных вершин
- d[u] — по окончании работы алгоритма равно длине кратчайшего пути из a до вершины u
- p[u] — по окончании работы алгоритма содержит кратчайший путь из a в u
  
**Сложность**
	- В простейшем случае, когда для поиска вершины с минимальным d[v] просматривается всё множество вершин, а для хранения величин d — массив, время работы алгоритма есть O(n2 + m). Основной цикл выполняется порядка n раз, в каждом из них на нахождение минимума тратится порядка n операций, плюс количество релаксаций (смен меток), которое не превосходит количества ребер в исходном графе.<BR>
	- Для разреженных графов (то есть таких, для которых m много меньше n²) непосещенные вершины можно хранить в двоичной куче, а в качестве ключа использовать значения d[i], тогда время извлечения вершины из станет O(logn), при том, что время модификации d[i] возрастет до logn. Так как цикл выполняется порядка n раз, а количество релаксаций не больше m, скорость работы такой реализации O(nlogn + mlogn)<BR>
	- Если для хранения непосещенных вершин использовать фибоначчиеву кучу, для которой удаление происходит в среднем за O(logn), а уменьшение значения в среднем за O(1), то время работы алгоритма составит O(nlogn + m).

##### Алгоритм А*

Является улучшение алгоритма Дейкстры, когда нужно найти кратчайший путь между 2 вершинами.

Добавляется эвристическая функция h(u) оценка расстояния от вершины u до целевой. Это должны быть оценка снизу, она не должна переоценивать расстояние до целевой вершины. Для задачи построения маршрута это может быть расстояние до цели по прямой.

В качестве приоритета вершины в очереди вместо d[u] используется d[u]+h[u].

Если положить h(u) = 0, то получим алгоритм Дейкстры.

Для случайного графа обходит меньшее число вершин, чем алгоритм Дейкстры. Может оказаться неэффективным в лабиринте.
