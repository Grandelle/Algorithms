Метод ветвей и границ (MIP - Mixed Integer Programming) - это метод оптимизации, который используется для решения задач, в которых присутствуют целочисленные переменные. Он является расширением линейного программирования и позволяет решать задачи с различными ограничениями и условиями.

Метод ветвей и границ работает путем разбиения задачи на более простые уровни, которые затем решаются методом линейного программирования. Эти уровни называются "ветвями" и создаются путем выбора одной из целочисленных переменных и разбиения задачи на две ветви: одна с переменной, которая принимает наименьшее целочисленное значение, а другая с переменной, которая принимает наибольшее целочисленное значение.

После этого решается каждая ветвь, используя метод линейного программирования, и происходит сравнение полученных результатов. Если находится оптимальное решение, то процесс останавливается, иначе происходит повторное разбиение задачи на новые ветви.

Метод ветвей и границ является одним из основных методов оптимизации и используется во многих областях, включая логистику, производство, экономику, финансы и т.д.

Условия применимости метода ветвей и границ

1. Для каждого частичного решения должна быть определена стоимость: 
    

Cost(a1,a2,...,ak)

2. Для всех частичных решений и их расширений должно быть выполнено Cost(a1,a2,...,ak-1) <=Cost(a1,a2,...,ak-1,ak). Тогда частичное решение (a1,a2,...,ak-1,ak) может быть отброшено, если его стоимость ≥ стоимости ранее вычисленных решений.
    

В большинстве случаев Cost(a1,a2,...,ak-1,ak) ≥ 0 и даже Cost(a1,a2,...,ak) = Cost(a1,a2,...,ak-1) + C(ak) где C(ak) ≥ 0 для всех ak

  
  

###### Общий алгоритм МВГ

S1 = А1;  k = 1;   cost = 0;   LowCost = + ∞;

while (k>0) { //пока не все решения найдены

     while ((Sk  != пустое множество) && (cost < LowCost) ) { // продвижение вперёд:

    ak = элемент из Sk; //выбор очередного элемента из Sk

     Sk = Sk - {ak};

     cost = f_cost (a1,…, ak-1,ak);

    if (((a1,…, ak-1,ak) – решение) && (cost < LowCost)){ 

  LowCost = cost;   /*фиксировать (a1,…, ak-1,ak) как текущий минимум */}

     else {

       // переход к следующему уровню

        k ++;

          вычислить Sk;

    }

    } // end while продвижения вперёд

  k --; // backtrack

  cost = f_cost (a1,…,ak);

} // последнее сохраняемое решение имеет наименьшую стоимость**