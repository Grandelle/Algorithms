

- Остовным деревом связного неориентированного графа называется его связный подграф, не имеющий циклов и содержащий все вершины исходного графа
- Если граф состоит из нескольких компонент связности, остовное дерево строится для каждой из его компонент
- Остовное дерево T, у которого суммарный вес его ребер w(T) = ∑(u,v)∈T w(u,v) минимален, называется минимальным остовным или минимальным покрывающим деревом.
**![](https://lh6.googleusercontent.com/Jbd5rDBhUEVOlUVBHWPCAH61tZuDjQo4qO3jo5I8qjVSQ_m09iZQF1AFxLWq40Y9dewLYr9QZb5ynbTfEraP_gyIO9XVv4s4XI6EqT8P9WobDYsy4XTwwVI5YtfkKUeQxBiJikd_r0-XOcAFkJdHrsw)**
**остновных деревьев из одного графа может быть больше одного**


### Условия при построении остовного дерева

- Считать все ребра положительными (достаточно добавить к весу всех ребер некоторую относительно большую положительную константу). В противном случае, если стоимость соединения между двумя вершинами равна отрицательному числу, можно несколько раз параллельно соединить их для уменьшения суммарного веса остовного подграфа.

- Для любой пары ребер их весовые характеристики будут различны. Это гарантирует уникальность построенного минимального остовного дерева.


### Общий алгоритм построения минимального остовного дерева

Пусть дан связный неориентированный граф G(V;E) 
c *n* вершинами и весовой функцией w: E → R.

Искомый остов строится постепенно. Алгоритм использует некоторый ациклический подграф А исходного графа G, который называется промежуточным остовным лесом. 

Изначально A состоит из n вершин-компонент, не соединенных друг с другом (n деревьев из одной вершины). На каждом шаге в A добавляется одно новое ребро. Граф A всегда является подграфом некоторого минимального остова. Очередное добавляемое ребро *e = (u, v)* выбирается так, чтобы не нарушить этого свойства: A ∪ {e} тоже должно быть подграфом минимального остова. Такое ребро называется безопасным.

Безопасным ребром *e* относительно некоторой компоненты связности К из А назовем ребро с минимальным весом, ровно один конец которого лежит в К.

**Применяемые алгоритмы**
	[[05 Алгоритм Прима]]
	 [[07. Алгоритм Борувки]]
	 [[06. Алгоритм Крускала]]